| Supported Targets | ESP32 | ESP32-C2 | ESP32-C3 | ESP32-C6 | ESP32-H2 | ESP32-S2 | ESP32-S3 |
| ----------------- | ----- | -------- | -------- | -------- | -------- | -------- | -------- |

# BMD101

使用 UART 接口通信，1 个起始位，8 个数据位，1 个停止位，波特率位 57600

## 串口输出的数据包格式

| Header            | Data Payload | CRC    |
| ----------------- | ------------ | ------ |
| SYNC SYNC plength | payload[]    | chksum |

包括 Header（帧头）、data payload（数据有效载荷）、CRC 校验字节三个部分。

- SYNC 字节（其值均为 0xAA） 指示一帧数据的开始。
- plength 字节（0-169） 指示数据有效载荷部分的字节数。
- Data Payload 是由一系列的 DataRow 组成。

### DataRow 组成

| [EXCODE]... | CODE  | [vLength] | value[]         |
| ----------- | ----- | --------- | --------------- |
| ox55...     | 0-255 | 0-255     | Depends on CODE |

- DataRow 起始位可能有零个或多个[EXCODE]（扩展代码）字节，这些字节的值均为 0x55。
- EXCODE 字节数表示 Extended Code Level。
- Extended Code Level 是用来与[CODE]字节一起确定 DataRow 的数据表示的是什么方面的信息。

#### [CODE]字节

值在 0x00 和 0x7F 之间，那么 DataRow 就没有[LENGTH]字节，紧跟着[CODE]的是一个字节的[DATA]值，然后 DataRow 结束。

值在 0x80 和 0xFF 之间，那么紧跟着是[LENGTH]，它表示[DATA]的字节数。

#### 通常我们从 BMD101 接收到的 DataRow 主要有三种：

[CODE]=0x02，即信号质量数据，信号质量是一个介于 0-200 之间的数据，数值越大表示传感器采集到的信号质量越好，等于 0 时可能是因为电极与人体接触不良。

[CODE]=0x03，即实时的心率数据，用一个字节表示。这也是 BMD101 的方便之处，开发者不必再通过算法求出心率，只需通过读取串口发送的心率数据即可，心率数据一般每秒发送一次，但在信号质量不佳时仍然会输出心率数据，因此在使用心率数据前应该验证信号质量是否过差。

[CODE]=0x80 时，输出的数据[DATA]表示原始的心电波形数据，每一个数据由 16 位补码组成，其值范围为-32768 到 32767 之间。这 16 位数据的第一个字节是高 8 位字节，第二个字节是低 8 位，为了通过这两个字节还原心电波形数据值，可以通过以下代码完成：
short raw =(Value[0]<<8) | Value[1];

[DATA]可能包含了很多个心电数据，因此可能由很多个字节组成，通常 BMD101 每秒输出 512 个原始心电波形数据，即采样率为 512Hz。

## 数据包解析步骤

从数据流中连续读取字节，直到[SYNC]字节（0xAA）时。

读取下一个字节，并确保它也是一个[SYNC]字节（如果没有，返回步骤 1）。

读[PLENGTH]字节。

从[PAYLOAD…]中读取下一个 PLENGTH 字节，把它们保存在一个存储区域（如
unsigned char payload [ 256 ]数组）。按照接收的顺序累加每一个字节到校验器中。

使校验器中的低 8 位取反。这里是 C 代码：
checksum &= 0xff；
checksum = ~ checksum & 0xff；

读取[CRC]字节并验证它是否符合你的计算校验和（如果没有，返回到步骤 1）。

循环，直到 payload[]数组中所有字节（也就是 DataRows）被解析：
a）解析和计算[EXCODE]字节的数值（0x55），一般在当前 DataRow 的开始。 b）解析当前 DataRow 中的[CODE]字节数据。 c）如果适用，解析当前 DataRow 中的[LENGTH]字节数据。d）分析和处理 当前 DataRow 中的[DATA…]字节（或数组），基于 DataRow 的 [EXCODE]等级、[CODE]和[LENGTH]。 e）如果不是所有的字节都从 payload []数组中解析完成，返回 a）解析下一个 DataRow。

## ESP32 实现数据包解析

配置 ESP32 串口位中断接收方式，在中断服务程序中，完成数据包的接收与保存工作

### 中断接收（Interrupt Receive）和非中断接收（Non-Interrupt Receive）

- 中断接收（Interrupt Receive）

  数据接收方式：当 UART 接收到数据时，会触发一个中断。中断处理程序（Interrupt Service Routine, ISR）会被调用来处理这些数据。这种方式允许系统在接收数据时立即响应，而不需要不断地轮询 UART 接口以检查是否有新数据到达。

  数据处理方式：数据通常在中断处理程序中处理，这意味着数据处理可以立即进行，而不需要等待主程序的下一个循环迭代。这对于实时系统或需要快速响应的应用程序非常有用。

  优点：能够实时处理数据，减少了 CPU 的空闲时间，提高了系统的响应速度。

  缺点：中断处理程序需要尽可能快速地执行，以避免阻塞其他中断或导致丢失数据。此外，如果中断处理程序的执行时间过长，可能会导致数据丢失。

* 非中断接收（Non-Interrupt Receive）

  数据接收方式：程序需要不断地轮询 UART 接口，以检查是否有新数据到达。这通常通过在主循环中使用 uart_read_bytes 函数来实现。

  数据处理方式：数据在主程序的循环中处理。这意味着数据处理可能会延迟，直到主程序的下一个循环迭代。

  优点：实现简单，不需要处理中断的复杂性。

  缺点：可能会导致 CPU 空闲时间增加，尤其是在数据接收不频繁时。此外，如果处理数据的时间过长，可能会导致数据丢失。

- UART 事件控制的特点

  事件驱动：UART 事件控制是事件驱动的，当 UART 接收到数据时，会触发一个事件，然后通过注册的事件回调函数来处理这些数据。这种方式避免了直接在 ISR 中处理数据，从而降低了 ISR 的复杂性和执行时间。
  灵活性：你可以根据需要注册不同的事件回调函数，例如，当接收到数据时、数据接收完成时、或者发生错误时，都可以通过不同的回调函数来处理。
  减少中断延迟：通过使用事件回调函数，可以减少直接在 ISR 中处理数据的延迟，从而提高系统的响应速度。
  更好的数据处理控制：你可以更精细地控制数据的处理流程，例如，你可以在数据接收完成后进行一些预处理，或者在数据发生错误时进行错误处理。
  与中断接收和非中断接收的区别
  中断接收：直接在 ISR 中处理数据，这种方式的优点是能够实时处理数据，但缺点是 ISR 的执行时间需要尽可能短，以避免阻塞其他中断或导致丢失数据。
  非中断接收：通过轮询 UART 接口来检查是否有新数据到达，然后处理数据。这种方式的优点是实现简单，但缺点是可能会导致 CPU 空闲时间增加，尤其是在数据接收不频繁时。
  UART 事件控制：结合了中断接收的实时性和非中断接收的简单性，通过事件回调函数来处理数据，提供了一种更灵活和高效的数据处理方式。
  总的来说，UART 事件控制提供了一种更加灵活和高效的数据接收方式，特别适合于需要精细控制数据处理流程的应用场景。
